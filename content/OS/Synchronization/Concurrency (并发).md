---
Author:
  - Xinyang YU
Author Profile:
  - https://linkedin.com/in/xinyang-yu
tags:
  - OS
Creation Date: 2023-09-24T12:23:00
Last Date: 2024-05-03T21:19:02+08:00
References: 
draft: 
description: 
---
## Concurrency (并发)
---
>[!quote]
> Concurrency is about **dealing with lots of things at once**, but parallelism is about **doing lots of things at once**.

- A way to run multiple [[Thread]] or [[Process (进程)]] at the same time, instead of running one thread or process after another thread or process is done
- We can achieve concurrency with multiple [[CPU#Core]], this is also known as [[#Parallelism (并行性)]]. We can also achieve concurrency with a single CPU core by performing [[Context Switch]]


>[!success] Maximise CPU utilisation + better user experience
> [[CPU]] is idle when the process and thread are performing non CPU-bounded tasks like reading and writing to [[OS/IO/IO Device|IO Device]] and waiting a result from a remote [[Host#Server]] etc. By performing context switch, we can let another process or thread to use CPU to complete its computation. Parallelism allows us to run multiple threads of processes at the same, if we have 4 CPU cores, it means we can have 4 processes/threads consuming the CPU at the same time.
> 
> The above describes about how concurrency helps with CPU utilisation. Concurrency also ensures users feel everything is running at the same like **browsing the web and playing music at the same time**. 

## Parallelism (并行)
---

![[parallelism.gif|500]]

- A subset of [[Concurrency (并发)]], [[Process (进程)]] and [[Thread]] run on their own [[CPU#Core]]. This is the true processing of multiple tasks at the same time, not an illusion created by quick [[Context Switch]]






## Corporative Scheduling
---
- Rather than the [[Kernel]] decides when to preempt a [[Process (进程)]] and pass the [[CPU]] to another process. Process passes control back to kernel for it to perform [[Process Management]]

>[!caution] CPU Hogging
> ![[corporative_scheduling_cpu_hogging.gif]]
> 
>Process can hog to CPU forever, modern OS adapts to [[#Preemptive Scheduling]] instead.

## Preemptive Scheduling
---

![[preemptive_scheduling.gif|500]]

1. Before [[Kernel]] set the [[Register#Program Counter]] to the [[Instruction]] of a selected [[Process (进程)]], the kernel sets the [[Timer Chip]] to trigger an [[Interrupts (中断)#Hardware interrupts (外中断)]] after some period of time([[Time Slice]])
2. The kernel switches the [[Privilege Level]] to [[Privilege Level#User Mode]] and set the program counter to the instruction of a selected process, so the process can start executing
3. When the timer chip elapses, it triggers a Hardware interrupts
4. The hardware interrupt invokes [[Trap Interrupt (陷入)]] which triggers the  corresponding [[Interrupt Handler]]
5. Interrupt handler passes control to [[Process Management#Process Scheduler]] when it completes
6. [[Process Management#Process Scheduler]] selects a process to run by restoring the state of the [[CPU]] for that process from the process's [[Process Control Block (PCB)]]
7. Repeat step 1 to step 6

>[!success] No CPU Hogging
> The hardware interrupt generated by timer chip ensures the kernel obtain control to perform [[Process Management]] on a configured interval. The eliminates any process from hogging the CPU forever which may happen in the case of [[#Corporative Scheduling]].

### Fixed Timeslice Round-Robin Preemptive Scheduling
- Give every [[Process (进程)]] the **same** [[Time Slice]], and the processes are **cycled through in order**

>[!caution]  Laggy Situation
>When there is a lot of [[Process (进程)]] like `100` and the time slice is a fixed `10ms`, one process needs to wait for `1000ms` before it gets to run again.

### Dynamic Timeslice Round-Robin Preemptive Scheduling

![[Dynamic_timeslice_round-robin_scheduling.png|500]]

- [[Time Slice]] = [[#Target Latency]] / the number of [[Process (进程)]]
- Used in modern [[Process Management#Process Scheduler]]

>[!important]
> Modern process scheduler also take in [[Process Management#Process Priority]] to ensure critical processes get more **CPU time** and **run more often**.

>[!success] Helps to make each process more responsive
>Ensures each Process will get to run again before it seems laggy to the user. As long as the [[#Minimum Granularity]] is ensured and [[#Target Latency]] is not exceeded.

>[!success]  Process gets to run faster when there is less Process
>The [[Time Slice]] is a ratio of Target Latency and total Process. Less process means more time for each process.

## Multi-tasking
---

![[multi_tasking.gif|500]]

- An extension of [[Multi-programming]]. The ability for [[Kernel]] to execute multiple tasks **at the same time** by giving each [[Process (进程)]] a very small [[Time Slice]], achieving [[Concurrency (并发)]]. Focusing on improving user experience
- The above animation shows only one [[CPU]], but multi-tasking can also be implemented on multiple [[CPU#Core]] to achieve [[#Parallelism (并行性)]]

>[!question] VS Time-sharing?
> In [[#Time-Sharing]], we have multi-users instead of multi-tasks. Multi-tasking focuses on the tasks, and the tasks can be from different users. So in that sense, multi-tasking is a superset of time-sharing.

### Time-Sharing

![[time-sharing.gif|500]]

- A implementation of [[Concurrency (并发)]] and a specific implementation of [[#Multi-tasking]] when [[CPU]] is shared by **multiple users** at the **same time**, achieved with quick [[Context Switch]]. This allow **multiple users** to **run jobs** on the **same computer** at the **same time** 
- All Time-sharing systems are [[Multi-programming]] systems

>[!info]
> The first time-sharing machine is invented at MIT in the early 1960s, machines before it are all [[OS#Batch System]].
>
> [Multics - Wikipedia](https://en.wikipedia.org/wiki/Multics) was one of the first time-sharing [[OS]] which inspires the creation of [[Unix]].

## References
---
- [Slice Dat Time | Putting the "You" in CPU](https://cpu.land/slice-dat-time)
- [CONCURRENCY IS AN ILLUSION - YouTube](https://youtu.be/3X93PnKRNUo?si=PsdliiPMP8fv3NoO)
- [Modern OS - 1.9 Research on Operating Systems](https://csc-knu.github.io/sys-prog/books/Andrew%20S.%20Tanenbaum%20-%20Modern%20Operating%20Systems.pdf)