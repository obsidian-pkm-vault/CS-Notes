---
Author:
  - Xinyang YU
Author Profile:
  - https://linkedin.com/in/xinyang-yu
tags:
  - OS
Creation Date: 2023-11-29T19:10:00
Last Date: 2024-02-17T19:14:01+08:00
References: 
---
## Interrupt
---
- When an interrupt occurs, [[Control Unit#Program Counter]] jumps to [[Interrupt Handler]] & execute 

>[!success] Free the CPU
> We don't need to get [[CPU]] to keep **Polling** for response which may take a long time to produce. Thus wasted computation


>[!caution] Generally can't be interrupted
> Allowed to run to completion. For example, if a keyboard's interrupt is interrupted, we may lose the input from the keyboard
> 
> However, there are exceptions (This part I haven't explored yet)

>[!caution] Busy State
> As long as the [[Interrupt Handler]] is running, other interrupts may not be handled, and interrupts are generally not queued
> 
> [[Interrupt Priorities]] exist in some systems to handle [[Simultaneous Interrupts]]

>[!tip]
>Interrupts should complete quickly to prevent the above problems

## Software Interrupt
---
- Also known as **Signal**
- Generated by the [[Process (进程)]], thus follow the [[Sequential Circuit#Synchronous Sequential Circuit]] behaviour
- Can be generated by [[Instruction]] like [[Trap Interrupt (陷入)]] to accomplish [[User Space]] to [[Kernel Space]] control transfers
- Part of the [[CPU]], for example the [[RISCV CLINT]] in RISCV CPUs

>[!example]- Turn off interrupt in XV6-RISCV
> This is achieved by writing to the [[Register#Control & Status Registers (CSRs)]] - `sstatus`. The code snippets below going down the [[Abstraction (抽象)]] 
> 
> `intr_off()` is the entry point
> ```c {8} title="spinlock.c"
> // XV6-RISCV kernel codes, spinlock.c
> 
> // ...
> void
> push_off(void)
> {
>   // ..
>   intr_off();
>   // ...
> }
> // ...
> ```
> 
> We can see from code snippet below, to disable the **interrupt** is setting the second bit from right on the `sstatus` register
> ```c {11} title="riscv.h"
> // XV6-RISCV kernel codes, riscv.h
> 
> // ...
> #define SSTATUS_SIE (1L << 1) // Supervisor Interrupt Enable
> 
> // ...
> // disable device interrupts
> static inline void
> intr_off()
> {
>   w_sstatus(r_sstatus() & ~SSTATUS_SIE);
> }
> // ...
> ```
> 
> Eventually, it boils down to [[Assembly language]]
> ```c {7} title="riscv.h"
> // XV6-RISCV kernel codes, riscv.h
> 
> // ...
> static inline void 
> w_sstatus(uint64 x)
> {
>   asm volatile("csrw sstatus, %0" : : "r" (x));
> }
> // ..
> ```

>[!success] Better Security
> Programs in User Space switching themselves is dangerous. With Software Interrupt, the [[CPU]] is preconfigured by [[Kernel]] with where in the kernel code to jump to

#### Signal Mechanism
1. Causes [[Process (进程)]] to temporarily suspend
2. Save its [[Register]] on the [[Stack]]
3. When [[Interrupt Handler]] is done, the running [[Process (进程)]] is restarted in the state it was in just before the signal

## Hardware interrupts (外中断)
---
- Follow the [[Sequential Circuit#Asynchronous Sequential Circuit]] behaviour
- Examples are [[Timer Chip]] for [[Multi-tasking]] where [[CPU]] is interrupted to take in inputs from keyboard for example

>[!example] Alarm Signal
> Sent after a specified number of seconds has elapsed to notify a process of an **event**